<!DOCTYPE html>
<html lang="en" class="theme-color-07cb79 theme-skin-light">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<META NAME="geo.position" CONTENT="21.028511, 105.804817">
<META NAME="geo.placename" CONTENT="Hanoi, Vietnam">
<META NAME="geo.region" CONTENT="vi">
<meta name="theme-color" content="#536878" />

<meta name="description" content="Dùng một framework là điều không khó, nhưng để dùng tốt thì không. Chúng ta thường bắt đầu với JPA/Hibernate quá dễ dàng, nhưng lại rất dễ bị mắc lỗi mà không hề hay biết." />

<!-- <link rel="stylesheet" href="../../../static/style.css"> -->
<title>Spring data JPA/Hibernate: Những sai lầm rất dễ gặp phải — luanvv.com</title>
<link rel="manifest" href="../../../static/manifest.json">
<!-- Favicon -->
<link rel="shortcut icon" type="image/ico" href="../../../static/img/favicon.ico" />
<!-- Google Fonts -->
<!-- <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Fredoka+One">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic,700,700italic,800,800italic"> -->
<!-- Icon Fonts -->
<!-- <link rel="stylesheet" type="text/css" href="../../../static/fonts/map-icons/css/map-icons.min.css"> -->
<link rel="stylesheet" type="text/css" href="../../../static/fonts/icomoon/style.css">
<!-- Styles -->
<link rel="stylesheet" type="text/css" href="../../../static/js/plugins/jquery.bxslider/jquery.bxslider.css">
<!-- <link rel="stylesheet" type="text/css" href="../../../static/js/plugins/jquery.customscroll/jquery.mCustomScrollbar.min.css"> -->
<!-- <link rel="stylesheet" type="text/css" href="../../../static/js/plugins/jquery.mediaelement/mediaelementplayer.min.css"> -->
<!-- <link rel="stylesheet" type="text/css" href="../../../static/js/plugins/jquery.fancybox/jquery.fancybox.css"> -->
<link rel="stylesheet" type="text/css" href="../../../static/js/plugins/jquery.owlcarousel/owl.carousel.css">
<link rel="stylesheet" type="text/css" href="../../../static/js/plugins/jquery.owlcarousel/owl.theme.css">

<link rel="stylesheet" type="text/css" href="../../../static/style.css">
<link rel="stylesheet" type="text/css" href="../../../static/colors/green.css">


<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
<!-- Modernizer for detect what features the user’s browser has to offer -->
<script type="text/javascript" src="../../../static/js/libs/modernizr.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script>
<!-- <script type="text/javascript" src="../../../static/js/service-worker.js"></script> -->
</head>
<body class="home "> <!-- add loading for progress bar -->
  <div class="mobile-nav">
    <button class="btn-mobile mobile-nav-close" aria-label="Close menu"><i class="rsicon rsicon-close"></i></button>

    <div class="mobile-nav-inner">
      <nav id="mobile-nav" class="nav">
        <ul class="clearfix">
          <li><a href="../../../vi/#about">About</a></li>
          <li><a href="../../../vi/#skills">Skills</a></li>
          <!-- <li><a href="../../../vi/#portfolio">Portfolio</a> </li> -->
          <li><a href="../../../vi/#experience">Experience</a></li>
          <li><a href="../../../vi/#education">Education</a></li>
          <!-- <li><a href="../../../vi/#references">References</a></li> -->
          <li>
            <!-- <a href="../../../vi/blog/">Blog</a> -->
            <a href="../../../vi/blog/">Blog</a>
          </li>
          <!-- <li><a href="../../../vi/#text-section">Future <span></span></a></li> -->
          <!-- <li><a href="../../../vi/#calendar">Calendar <span></span></a></li> -->
          <!-- <li><a href="../../../vi/#contact">Contact <span></span></a></li> -->
        </ul>
      </nav>
    </div>
x`
  </div><!-- .mobile-nav -->
  <div class="wrapper">
    <header class="header">
      
      <div class="head-bar">
        <div class="head-bar-inner">
          <div class="row">
            <div class="col-xs-9 col-sm-6 col-md-3">
              <a class="logo" href="../../../vi/"><span>Luan</span>'s blog</a>
              <!-- <a class="head-logo" href=""><img src="img/rs-logo.png" alt="RScard"/></a> -->
            </div>
            <div class="col-xs-3 col-sm-6 col-md-9">
              <div class="nav-wrap">
                <nav id="nav" class="nav">
                  <ul class="clearfix">
                    <li><a href="../../../vi/#about">About</a></li>
                    <li><a href="../../../vi/#skills">Skills</a></li>
                    <!-- <li><a href="../../../vi/#portfolio">Portfolio</a> </li> -->
                    <li><a href="../../../vi/#experience">Experience</a></li>
                    <li><a href="../../../vi/#education">Education</a></li>
                    <!-- <li><a href="../../../vi/#references">References</a></li> -->
                    <li>
                      <!-- <a href="../../../vi/blog/">Blog</a> -->
                      <a href="../../../vi/blog/">Blog</a>
                    </li>
                    <!-- <li><a href="../../../vi/#text-section">Future <span></span></a></li> -->
                    <!-- <li><a href="../../../vi/#calendar">Calendar <span></span></a></li> -->
                    <!-- <li><a href="../../../vi/#contact">Contact <span></span></a></li> -->
                  </ul>
                </nav>
                <button class="btn-mobile btn-mobile-nav">Menu</button>
                <!-- <button class="btn-sidebar btn-sidebar-open"><i class="rsicon rsicon-menu"></i></button> -->
              </div>
            </div>
          </div>
        </div>
      </div>
    </header><!-- .header -->
    <div class="content">
        <div class="container">
      
<div class="row animate-up animated">
  <div class="col-sm-12">
    <main class="post-single">
      <article class="post-content section-box">
          <header class="post-header">
            <div class="post-data">
              <div class="post-title-wrap">
                <h1 class="post-title">Spring data JPA/Hibernate: Những sai lầm rất dễ gặp phải</h1>
              </div>
              <div class="post-tag">
                <a href="../../../tags/dev">
                      #dev
                    </a>
                <a href="../../../tags/java">
                      #java
                    </a>
                <a href="../../../tags/jpa">
                      #jpa
                    </a>
                <a href="../../../tags/hibernate">
                      #hibernate
                    </a>
                
              </div>
              <div class="post-info">
                <a href="javascript: void(0)"><i class="rsicon rsicon-user"></i>by luanvv</a>
                <a href="javascript: void(0)"><i class="rsicon"></i>Nov 11 2018</a>
              </div>
            </div>
          </header>
          <div class="post-media">
              <img class="lozad"
                src="../../../static/img/uploads/458x300.png" 
                data-src="../../../static/img/covers/jpa-hibernate.jpg" 
                alt="Spring data JPA/Hibernate: Những sai lầm rất dễ gặp phải" />
            </div>
        <div class="post-inner">
          <div class="post-editor clearfix">
            <p>Điều tuyệt vời của JPA(Java Persistence API) hay ORM(Object-relational mapping) là nó giúp bạn có thể quên đi những thao tác với RDBMS(Relational database management system), nhưng điều tồi tệ về JPA cũng chính là điều đó. Bạn sẽ đắm chìm trong những câu lệnh Java, câu lệnh JPQL, HQL mà quên đi những câu lệnh SQL được sinh ra đang âm thầm kéo chương trình của bạn xuống đáy.</p>
<p>Và ngoài những lỗi chủ quan do chưa đủ kiến thức về thư viện, thì những thư viện như Spring Data JPA/Hibernate, khách quan mà nói thì chúng không hề hoàn thiện (nếu hoàn thiện rồi thì cần gì suốt ngày update). Thư viện là của người ta, nhưng người phải nhận lỗi lại chỉ có bạn, nên phải tự biết lo cho chính mình.</p>
<p>Những điều dưới đây phụ thuộc rất nhiều vào loại database, phiên bản của Spring Data JPA hay Hibernate. Do vậy, nó có thể không tuyệt đối đúng với trường hợp của mọi người, nhưng hãy luôn coi chừng chúng.</p>
<h2>Thứ nhất, bỏ quên Eager Fetching</h2>
<p>Thời điểm đầu tiên khi sử dụng Hibernate, mình không hề biết: Fetching Type mặc định của <em>ManyToOne </em>là <strong>EAGER Fetching</strong>. Một ngày đẹp trời, sếp quay ra hỏi: <em>“Sao đoạn này select có một record mà câu SQL nó dài 2 trang A4 với 30 câu JOIN thế này?”</em>. Lúc này mới té ngửa ra đi tìm hiểu, cảm giác mình rất chi là “<em>gà</em>”.</p>
<p>EAGER Fetching là một tính năng rất hay của Hibernate, nó giúp bạn sử dụng ORM một cách tự nhiên hơn.</p>
<p>Ta thử với các bảng dưới đây</p>
<p><img src="../../../static/img/uploads/1RGPjO76yL01nt41sO3cmoA.png" alt=""></p>
<p>Hibernate là ORM, bạn query để lấy ra <em>User, </em>thì một cách tự nhiên nhất, bạn sẽ lấy ra được <em>Office</em>.</p>
<p><img src="../../../static/img/uploads/1YHjgn57s_uXep399spVFYQ.png" alt=""></p>
<p><img src="../../../static/img/uploads/17E_S3MKs0UGOFJUrKyfodA.png" alt=""></p>
<p>Điều này có lợi khi bạn là người chưa hiểu nhiều về Hibernate hoặc cần phát triển chương trình một cách nhanh chóng.</p>
<p>Nhưng, cái giá phải trả là không hề nhỏ. Đây là câu SQL được sinh ra:</p>
<p><img src="../../../static/img/uploads/133ogQTVapTq5sx0bCjYhHQ.png" alt=""></p>
<p>rất nhiều column được select và câu lệnh này join với hết các bảng. Đây mới là trường hợp đơn giản, còn trên thực tế, các bảng có thể có liên hệ với nhau nhiều hơn. Bảng User có quan hệ n-1 đến nhiều bảng hơn nữa, trong đó có Office, Office có thể có quan hệ n-1 với bảng khác, và cứ thế, câu lệnh của bạn sẽ có hàng dài <em>join. </em>Đúng là dùng thì dễ, nhưng để dùng tốt lại là chuyện khác.</p>
<p>Như đã nói ở trên là mình đã gặp trường hợp Hibernate sinh ra câu lệnh join với hơn <strong>30 bảng</strong>(80% số bảng trong database) với chỉ một câu query ra từ entity, và trong hầu hết tình huống thì đó không phải là điều mình(chúng ta) cần, query như vậy sẽ làm giảm performance rất rõ rệt. Đây là điều mà khi start code dự án được 6 tháng, cả đội Dev mới phát hiện ra.</p>
<p>Và trừ khi bạn dùng native SQL hoặc chọn từng property của <strong>User </strong>entity để lấy ra, còn nếu không, bạn hoàn toàn <strong>không thể tránh được</strong> các câu lệnh join ở trên, đây cũng chính là một “<em>điểm chết</em>” của Eager Fetching Type này. Bạn rất khó để thay đổi nó!</p>
<p>Hãy đọc thêm về Fetching type của Hibernate trong phần reference để hiểu rõ hơn(mình hơi lười viết), tránh lỗi trên và lỗi <strong>N+1 Query, </strong>một lỗi vô cùng phổ biến trong Hibernate sẽ được nói ở dưới.</p>
<h3><strong>Cách khắc phục</strong></h3>
<p>Khuyến khích dùng Lazy Fetching cho hầu hết các trường hợp(trừ khi bạn có lý do thật đặc biệt). Với trường hợp <em>ManyToOne</em> hay <em>OneToOne</em>, hãy cài đặt <strong>Lazy Fetching</strong>. Còn trường hợp <em>OneToMany </em>và <em>ManyToMany </em>thì đừng làm gì cả, mặc định nó đã là <strong>Lazy Fetching</strong> rồi.</p>
<p><strong>Không nên</strong></p>
<p><img src="../../../static/img/uploads/11XD8acsiEpolzhk8hfG4xw.png" alt=""></p>
<p><strong>Nên</strong></p>
<p><img src="../../../static/img/uploads/1i2JnN47DSwIZpFs1-8Ycag.png" alt=""></p>
<p>Khi bạn viết câu select, bạn có thể tùy ý chọn lựa việc join lấy ra những property nào(hoặc entity nào), join với bảng nào, tất cả đều nằm trong tay bạn.</p>
<h3>Thứ hai, không lấy ra những thông tin cần thiết từ các bảng quan hệ</h3>
<p>Cuộc sống luôn có những điều trái ngang!</p>
<p>Nếu bạn sử dụng <strong>Lazy Fetching </strong>như ở trên thì lại gặp trường hợp <em><a href="https://docs.jboss.org/hibernate/orm/3.5/api/org/hibernate/LazyInitializationException.html">org.hibernate.LazyInitializationException</a></em>, hoặc đau đớn hơn là vấn đề N+1 query âm thầm tiêu diệt chương trình của bạn một cách chậm rãi.</p>
<h3>LazyInitializationException và N+1 query</h3>
<p>Các vấn đề này xảy ra do đâu? Cùng xem ví dụ bên dưới.</p>
<p>Giả sử ta có bài toán cần lấy ra thông tin của user, bao gồm cả company của user đó. Cùng nhìn lại đoạn mapping của <strong>User</strong> entity:</p>
<p><img src="../../../static/img/uploads/1MuOtYlF6HAZJ8dTXrDP3YQ.png" alt=""></p>
<p>và code lấy ra thông tin</p>
<p><img src="../../../static/img/uploads/1R2JOfiA4C-FuE9cMExupgw.png" alt=""></p>
<p>Nên nhớ fetching type của association <strong>Company </strong>đã là Lazy, sẽ không còn câu lệnh join với bảng Company nữa, giờ SQL sẽ như sau:</p>
<p><img src="../../../static/img/uploads/1elYctH1cqEN8jnXUSfJV8A.png" alt=""></p>
<p>Hãy để ý trong trường hợp trên, Hibernate sẽ lấy tất cả các column của bảng User, bao gồm cả các FK(car_id, office_id và company_id). Dữ liệu trong bảng User là</p>
<pre><code>car_id = *null;*
office_id = *null;*
company_id = *1;*
</code></pre>
<p>khi nhận thấy FK company có giá trị, Hibernate lập tức khởi tạo một object Company(dù ta chưa hề join) và gán id cho nó bằng 1. Điều đó có nghĩa là ta có thể lấy ra id của company object từ user một cách bình thường, nhưng <em>code</em> của company đó thì không.</p>
<p><img src="https://cdn-images-1.medium.com/max/2666/1*HDm49JG67jyJllx-9WSc8Q.png" alt=""></p>
<p>Hãy hiểu lỗi này đơn giản rằng: nếu bạn phải viết những câu SQL lấy ra cả user và company mà không phải join(không chơi cross join luôn), bạn phải lấy ra <em>company_id</em> từ bảng <strong>User</strong>, sau đó lại lấy giá trị đó để select tiếp trong bảng <strong>Company</strong>.</p>
<p>Hibernate cũng làm tương tự như vậy.</p>
<ul>
<li><p>Lấy ra tất cả các trường của bảng User, bao gồm cả FK</p>
</li>
<li><p>FK nào null thì bỏ qua, nếu không null thì tạo ra một đối tượng, gán FK vào, trong trường hợp này là <em>company_id</em>.</p>
<p>office = null
  car = null
  company = ???</p>
</li>
</ul>
<p><img src="../../../static/img/uploads/1EX0s-u2gglu27LmSlkfpeQ.png" alt=""></p>
<p><img src="../../../static/img/uploads/1ZJ8mz_VgUWx-rHpO4JL-bw.png" alt=""></p>
<p>Vậy là Hibernate đã khởi tạo company bằng một instance của một class hơi khang khác(proxy object) so với của ta khai báo, từ đó mà nó có thể làm thêm điều bên dưới</p>
<ul>
<li>Chưa vội select bảng Company ngay. Đến khi bạn lấy ra <strong>bất kỳ trường nào ngoài PK</strong>(ở đây mình thử lấy ra <em>code</em>) thì Hibernate sẽ cố gắng gọi truy vấn đến bảng company và lấy đầy đủ thông tin hơn.</li>
</ul>
<p>Tai nạn xảy ra ở đây là để truy vấn database, Hibernate phải có <em>session</em>(hay với database thì nó là connection), mà <em>session </em>thì phải mở thì mới có, chứ không mở hoặc đóng mất tiêu rồi thì nó bó tay, đấy là lý do tại sao message trong exception lại là <strong>no Session</strong>.</p>
<p>Thử thêm một đoạn code hơi kì cục vào <em>Service </em>method</p>
<p><img src="../../../static/img/uploads/1sr_31iubzkPwLT9b7Muhew.png" alt=""></p>
<p>và chạy lại đoạn test, ngoài câu lệnh select user, thêm một câu SQL nữa sẽ được sinh ra</p>
<p><img src="../../../static/img/uploads/1M9U4IMJbsM_YNm8RdCGtcw.png" alt=""></p>
<p>và lỗi đã biến mất.</p>
<p>Cách lý giải đơn giản là khi sự kiện lấy company code được viết trong service, khi session(connection) chưa được đóng thì Hibernate có thể lấy từ database một cách bình thường. Và cái giá phải trả, chính là thêm một câu lệnh SQL nữa.</p>
<p>Đây không phải là giải pháp tốt nhất trong trường hợp này! Tại sao? Vì đây chính là nguyên nhân của <strong>N+1 query.</strong></p>
<p>Nếu bạn cho rằng thêm 1–2 câu query có là gì, thì…bạn nói đúng rồi đấy. Nhưng thử tưởng tượng, bạn lấy ra không phải 1, mà là 100 user, khi đó ta chỉ cần 1 câu query để lấy ra cả danh sách 100 user, nhưng xui xẻo thay là ta lại mất 100 query tới <strong>Company </strong>table như trên nữa để lấy ra company của <strong>từng user một</strong>(bỏ qua cache).</p>
<p>Vậy là, bạn chỉ cần <strong>1</strong> câu query để lấy ra <strong>N</strong> entity chính, nhưng lại mất <strong>N </strong>câu query nữa để lấy ra đối tượng quan hệ của nó, tên <strong>N+1 query</strong> từ đó mà ra.</p>
<p>Cái nguy hiểm của <strong>N+1 query </strong>chính là bạn sẽ không nhìn thấy bất kỳ exception nào hoặc thậm chí trong suốt thời gian phát triển thì chương trình vẫn chạy “<em>ầm ầm”</em> theo như các dev nói. Nhưng đến lúc hàng đống data test hoặc thậm chí đưa lên môi trường production, khách hàng đợi 5' chưa thấy mặt website thì cả đội rất dễ đi bán muối.</p>
<h3>Cách khắc phục</h3>
<ol>
<li><strong>Dùng câu lệnh FETCH trong JPQL/HQL.</strong></li>
</ol>
<p>Đây là cách mình hay dùng nhất, vừa gọn, vừa tường minh, lại vừa đơn giản.</p>
<p><img src="../../../static/img/uploads/1G_TUZx9b7hVExD6PpLhX_g.png" alt=""></p>
<p>Câu lệnh SQL được sinh ra khá giống với tùy chọn Eager Fetching</p>
<p><img src="../../../static/img/uploads/1_VhkkGTlR1GgnyjBoWjR4g.png" alt=""></p>
<p>Có rất nhiều cách mà không biết vì vô tình hay cố ý mà Spring tự động lấy ra dữ liệu cho bạn tương tự khi viết thêm FETCH. Nhưng do nó quá “<em>tùm lum</em>” nên thôi, mình cứ viết FETCH vào cho chắc.</p>
<p><strong>2. Dùng EntityGraph</strong></p>
<p>Giả sử ta có database như sau:</p>
<p><img src="../../../static/img/uploads/1JUl98uSj2zv9zIGX6SiEqA.png" alt=""></p>
<p>Mỗi company có nhiều office, mỗi office lại có nhiều user. Giờ mình cần lấy ra đối tượng company, đồng thời lấy ra tất cả office của company đó, và tiếp nữa là lấy ra tất cả các user của mỗi office.</p>
<p>Ví dụ có thể thấy như dưới đây, mong muốn chương trình in ra đầy đủ office và user.</p>
<p><img src="../../../static/img/uploads/1A6rCrfloSt3SB_g2HgzbbQ.png" alt=""></p>
<p>Nhiều bạn chưa nắm rõ về Hibernate, rất dễ mắc lỗi <strong>N+1 query </strong>hoặc <strong>LazyLoad</strong> do không chú ý. Cũng có bạn chọn giải pháp dùng nhiều câu SQL để lấy ra. Nhưng như vậy thì thường quá, dưới đây mình chỉ dùng <strong>duy nhất một câu SQL</strong> để lấy ra tất cả!</p>
<p>Với yêu cầu bài toán này thì bạn hoàn toàn có thể dùng chỉ 1 câu HQL(cũng chỉ là một câu SQL) để lấy ra tất cả, sau đó dùng code Java để nhóm lại. Đây là cách trước đây mình hay dùng. Nhưng cách này không hay khi bạn phải suy nghĩ câu HQL quá đau đầu, lại còn phải viết Java để nhóm lại cũng choáng váng không kém. Nói chung là cũng tầm thường không kém cách trên(thế mà trước mình dùng suốt đấy). Ơn giời, hãy để JPA/Hibernate làm cả 2 việc đó giúp bạn bằng <strong>EntityGraph.</strong></p>
<p>EntityGraph sẽ giúp bạn lấy ra những đối tượng association một cách tự động rất dễ dàng. Nghe có vẻ giống Eager fetching? Không hề, với EntityGraph, đầu tiên là bạn có thể tùy chọn mối liên hệ giữa nhiều entity, như một graph vậy, từ entity này link sang entity khác, rồi từ entity đó lại link sang entity khác nữa. Và điều khác biệt nhất so với Earger fetching, là bạn có thể lựa chọn có sử dụng hay không(và mình thích được lựa chọn.).</p>
<p>Cùng xem cách làm</p>
<p><strong>Bước 1:</strong> Ở Company entity, ta thêm anonnation NamedEntityGraph</p>
<p><img src="https://cdn-images-1.medium.com/max/2548/1*C__VwolB3eLjkxUevn8EaA.png" alt=""></p>
<p>Đặt tên là “<strong>graph.Company.offices</strong>”</p>
<p>Đặt node(có thể có nhiều node) offices và lấy ra tất cả đối tượng office của company. Và node này lại có thể có nhiều subgraph, tức là từ mỗi office ta có thể lấy ra nhiều thứ khác nữa, ở đây ta lấy ra tất cả các user của mỗi office.</p>
<p><strong>Bước 2: </strong>Khai báo sử dụng trong repository</p>
<p><img src="https://cdn-images-1.medium.com/max/2002/1*e9fPnK19ndEgFP_uL1rEGg.png" alt=""></p>
<p>Với Query method, bạn có thể trực tiếp sử dụng EntityGraph anonnation. Còn nếu bạn dùng JPQL/HQL thì bạn phải lấy EntityGraph thông qua EntityManager và dùng method <em>setHint</em></p>
<p>Đoạn code lấy ra kết quả</p>
<p><img src="../../../static/img/uploads/1EEOkaTJ0Vd_ohMbvqJYS4Q.png" alt=""></p>
<p>Đã xong, bây giờ chạy nó, 1 câu lệnh SQL duy nhất được tạo ra:</p>
<p><img src="../../../static/img/uploads/1XfUFewc5ZlRXR1xOT7aqFQ.png" alt=""></p>
<p>Và đây là output:</p>
<pre><code>Office Id: 1

User Id:   1

Office Id: 2

User Id:   2
</code></pre>
<p>Rất ổn đúng không!</p>
<p>Cả <em>LazyInitializationException </em>và <em>N+1</em> query đều không phải thiếu xót hay sai lầm của Hibernate, nó là <strong>một tính năng</strong>. Nhưng cần hiểu rõ <em>“tính năng đó” </em>để tránh những cái ngớ ngẩn trên.</p>
<h3>Thứ ba, dùng Hibernate như JDBC</h3>
<p>Hãy dùng Hibernate đúng cách và hiệu quả nhất.</p>
<p>Điểm lợi lớn nhất của một ORM là nó giúp bạn quên đi những đối tượng database mà tập trung vào việc thao tác thông qua các model. Tất cả các công nghệ CRUD thao tác trên model, cache, custom SQL, sort, auditing date, graph… đều “<em>đổ sông đổ biển</em>” nếu bạn chỉ dùng native SQL!</p>
<p>Tại sao bạn lại bê nguyên một framework đồ sộ như Hibernate chỉ để nó mở connection tới database cho bạn, và bạn thì chỉ dùng nó để gọi đến store procedure của database?</p>
<p>Khi bạn sử dụng một công cụ quá phức tạp cho những điều đơn giản, hoặc nó không phù hợp với bài toán mà bạn cần, đừng ép nó! Các vấn đề về thời gian boot (nhiều thư viện hơn đồng nghĩa với việc JVM phải load nhiều class hơn), cách xử lý qua nhiều tầng gây chậm chương trình không cần thiết, nhiều vấn đề phải học hơn (nhiều chức năng quá cũng nguy hiểm).</p>
<p>Kinh nghiệm của mình là: đừng áp đặt thói quen sử dụng của bạn lên những dự án không phù hợp. Nếu bạn cần một dự án siêu nhỏ và siêu đơn giản, hãy dùng JDBC đơn thuần. Nếu dự án phải viết một lượng lớn native SQL hoặc dùng store procedure nhiều hơn là thao tác với model, hãy nghĩ đến Mybatis, jdbcTemplate, chúng cung cấp những công cụ rất tốt cho việc viết native SQL. Một số trường hợp bạn cũng có thể dùng kết hợp giữa nhiều framework(ví dụ dùng cả Hibernate và JDBC Template), không vấn đề gì cả.</p>
<h3>Thứ tư, sử dụng compose primary key một cách bất cẩn</h3>
<p>ORM cung cấp những tiện lợi cho việc thao tác với RMDB. Không cần viết native SQL, ta vẫn có thể thao tác với database thông qua các <strong>model object </strong>và dùng method của JPA, JPQL, HQL, Criteria, Example, Specifications,… Nghe có vẻ lý tưởng, nhưng chính việc bỏ quên native SQL và sử dụng model object lại chính là nguyên nhân gây ra nhiều lỗi ngớ ngẩn. Dưới đây là một trong những lỗi đó.</p>
<p><a href="https://www.w3schools.com/sql/sql_in.asp">IN Operator</a> là một operator khá phổ biến trong SQL, trong nhiều trường hợp nó còn cho performance tốt hơn <strong>Equal Operator</strong>(=). JPA/Hibernate cũng hỗ trợ bạn sử dụng IN Operator. Ta cùng xem ví dụ.</p>
<p><em>Ta có hai bảng <strong>Account </strong>và <strong>User</strong></em>(một số trường có thể hơi khác do mình quá lười để viết thêm)<strong>. </strong>Bảng User đặc biệt hơn, với 1 compose primary key gồm 2 trường: key1 và key2</p>
<p><img src="../../../static/img/uploads/1xNP1qd6LYAwAdtt9CwXaEQ.png" alt=""></p>
<p>Thử viết câu HQL dùng IN Operator với bảng <strong>Account</strong></p>
<p><img src="../../../static/img/uploads/1ptKnBQYQW9sbOoLRO33akA.png" alt=""></p>
<p>Và dưới đây là câu lệnh ta nhận được khi Hibernate compile ra native SQL</p>
<p><img src="../../../static/img/uploads/1T5ST3Qq5pPba5EfKRaRMEA.png" alt=""></p>
<p>Câu lệnh SQL trên sẽ chạy bình thường và cho ra kết quả chính xác mà bạn mong muốn.</p>
<p>Bây giờ ta thử với bảng <strong>User</strong>, bảng có 1 compose primary key(<em>key1</em> và <em>key2</em>). Vì ta thao tác với model object nên chỉ cần biết identity key của <strong>User</strong> là id, thực tế trong RDBMS là gì, không quan trọng, lý thuyết là vậy.</p>
<p>Dưới đây là một đoạn code mapping của bảng <strong>User</strong></p>
<p><img src="../../../static/img/uploads/1AB0G47Qe8C6ZS4N3nKQJfA.png" alt=""></p>
<p><img src="../../../static/img/uploads/1qkxzmoavWfT86v4DFR4NLA.png" alt=""></p>
<p>Và đây là câu HQL dùng để select</p>
<p><img src="../../../static/img/uploads/16TXfgd1fVyMYGmNyHiA6yw.png" alt=""></p>
<p>Trông có vẻ ổn!</p>
<p>Câu lệnh HQL trên sẽ được Hibernate compile ra SQL một cách bình thường. Đây là kết quả:</p>
<p><img src="../../../static/img/uploads/14QVuhbfCNWFdEfd5KOHwVw.png" alt=""></p>
<p>Câu lệnh trên rõ ràng là sai. Cú pháp hợp lệ nhưng kết quả thì không.</p>
<p>Câu lệnh SQL nên là:</p>
<p><img src="../../../static/img/uploads/1bXpbe-oxGlWp3acRZdn0fw.png" alt=""></p>
<p>Trường hợp tương tự khi bạn sử dụng điều kiện hỗn hợp, trong đó có một điều kiện sử dụng với composite primary key</p>
<p>Ta thử dùng một method trong repository của User entity</p>
<p><img src="../../../static/img/uploads/1pwzoBlSy5vPn8VPveg26PA.png" alt=""></p>
<p>Câu lệnh SQL được compile ra, sai hoàn toàn:</p>
<p><img src="https://cdn-images-1.medium.com/max/2684/1*QqyyzQ2P_yxz7e4hq8VINg.png" alt=""></p>
<p>Thử dùng HQL và <em>trick</em> thêm dấu ngoặc</p>
<p><img src="../../../static/img/uploads/1WD3Jd5VAyKK1fXdPo2LBcQ.png" alt=""></p>
<p>nhưng kết quả không khác</p>
<p><img src="https://cdn-images-1.medium.com/max/2684/1*QqyyzQ2P_yxz7e4hq8VINg.png" alt=""></p>
<p>Tương tự thì Criteria, Specifications cũng chung một kết cục.</p>
<h3>Cách khắc phục</h3>
<p>Cho đến hiện nay thì mình vẫn chưa tìm ra cách khắc phục ngoài việc dùng cách <em>stupid </em>nhất là native SQL thay thế.</p>
<p>Đây chỉ là một trong những ví dụ cho bạn thấy, dù Hibernate không hề có biểu hiện lỗi compile hay runtime thì cũng không có nghĩa là kết quả bạn ra đã đúng. Hãy coi chừng.</p>
<h3>Thứ năm, không lường được kết quả trả về</h3>
<p>Trong suốt quá trình sử dụng Spring JPA, mình đã gặp một số bug thậm chí có bug thật sự là “<em>sấm sét</em>” liên quan đến kiểu trả về khi thao tác bằng Spring JPA. Cùng xem một số dưới đây:</p>
<ol>
<li><strong>Nếu bạn chỉ định kiểu trả về là Collection hoặc Array thì chắc chắn nó không bao giờ null</strong></li>
</ol>
<p>Mình thấy nhiều bạn hay code như sau</p>
<p><img src="../../../static/img/uploads/12q_X9x45Sb8_ryqVQcae4A.png" alt=""></p>
<p>Bạn nên bỏ điều kiện kiểm tra null, vì dù thế nào đi chăng nữa, data cũng sẽ không bao giờ null.</p>
<p><strong>2. Thấy trả về null, cứ tưởng là record không tồn tại</strong></p>
<p>Tình huống là ta chỉ cẩn lấy ra một field của entity, code như sau:</p>
<p><img src="../../../static/img/uploads/1YuC5DUodZoodrL3zLW7ESQ.png" alt=""></p>
<p>Có bạn code như thế này:</p>
<p><img src="../../../static/img/uploads/1x815klDfW2_LXD2Gpx_WBQ.png" alt=""></p>
<p>Nếu bạn code bằng JDBC đơn thuần, sử dụng <em>ResultSet </em>hoặc sử dụng query thông qua <em>EntityManager </em>thì rõ ràng trường hợp không có record nào và record chứa một field mang giá trị <strong>null</strong> nó là khác nhau hoàn toàn, nhưng Spring Data JPA trong cách viết này thì không, nó không phân biệt.</p>
<p>Thử đoạn test</p>
<p><img src="../../../static/img/uploads/1wD6kBUP_5-MiN5qFD6wPoQ.png" alt=""></p>
<p>Mình thêm một company(với code là null) vào database, sau đó lấy ra bằng method <em>getCodeById</em> ở trên, mong muốn là code này sẽ là null, nhưng kết quả lại là exception javax.persistence.EntityNotFoundException(nhưng rõ ràng Company có tồn tại mà?), khá cay đắng nhưng sự thật là vậy.</p>
<p>Giờ thay vì dùng một id có tồn tại, mình chọn một id không tồn tại</p>
<p><img src="../../../static/img/uploads/1xCH9DuMfHxYX7H0_nMw2JA.png" alt=""></p>
<p>Kết quả vẫn là exception javax.persistence.EntityNotFoundException.</p>
<p>Làm sao phân biệt? Câu trả lời là không thể nếu bạn select như vậy. Hãy select thêm trường để tạo sự khác biệt</p>
<p><img src="../../../static/img/uploads/10SUpSkSAG3Z5dR6EZomdXQ.png" alt=""></p>
<p>Nhiều bạn sẽ thắc mắc ở đây là tại sao không lấy ra mảng Object thôi, tại sao lại phải list mảng object. Thì câu trả lời là dù bạn khai báo kiểu trả về là <strong><em>Object[]</em></strong> thì trên thực tế trả về vẫn là <strong><em>Object[][]</em></strong>, và bạn phải cast rất nhiều mới lấy ra cái cần, vậy nên hãy luôn trả về <strong><em>List&lt;Object[]&gt;</em></strong> dù bạn chỉ lấy 1 record(tuyệt đối đừng bao giờ là <strong><em>Object[]</em></strong> với nhiều field)</p>
<p>Sửa service như sau:</p>
<p><img src="../../../static/img/uploads/1jnQRFWycutEsNPi3N059sQ.png" alt=""></p>
<p>Giờ thì kết quả đúng ý rồi.</p>
<p><strong>3. Khai báo một đằng nhưng trả về một nẻo</strong></p>
<p>Đây thực sự là một bug “<em>sấm sét</em>” của Spring Data JPA(hay có lẽ là cả Java thì đúng hơn) mà mình đã gặp phải.</p>
<p>Chẳng là mình có một list id được lưu kiểu String từ thư viện bên thứ ba trả về, mình cần phải so sánh nó với các id(kiểu số nguyên) có trong database.</p>
<p>Cách mình làm:</p>
<p>Lấy ra các id trong database với kiểu <strong>String</strong>(có lẽ là nó sẽ cast từ int sang String được vì id của company khai báo là <strong>int</strong>)</p>
<p><img src="../../../static/img/uploads/1AtoRolEr49JwrY0bwxQjfA.png" alt=""></p>
<p>Giả sử trong database hiện đang có 10 company với id từ 1 đến 10.</p>
<p>Thử với test dưới đây</p>
<p><img src="../../../static/img/uploads/1bqdicNvJPuHsTgr0SyiYhw.png" alt=""></p>
<p>Đáng lẽ test trên phải pass, nhưng kết quả lại fail! Tại sao? Rõ ràng trong database có id từ 1 đến 10, <em>ids “nên” </em>có dạng</p>
<pre><code>["1", "2", "3", "3", "4", "5", "6", "7", "8", "9", "10"]
</code></pre>
<p>thì chắc chắn nó phải chứa <em>“1”</em>.</p>
<p>Nhưng, mình đã bị <em>chúng </em>lừa. Biến ids vẻ ngoài là <strong><em>List&lt;String&gt;</em></strong>, nhưng “<em>tâm hồn</em>” lại là <strong><em>List&lt;Integer&gt;</em></strong></p>
<p>Thử đổi lại</p>
<p><img src="../../../static/img/uploads/1GrOaJvcfZBx9lpO5qEdDHQ.png" alt=""></p>
<p>đoạn code có warning, không vấn đề, nó vẫn pass.</p>
<p>Giờ ta không trả về String hay Integer nữa, trả hẳn về Double</p>
<p><img src="../../../static/img/uploads/1lL924TN1IQ8GZQNsxyVopA.png" alt=""></p>
<p>thì trên thực tế cái được trả về vẫn là <strong><em>List&lt;Integer&gt;</em></strong></p>
<p>Mình chưa có dịp tìm hiểu sâu nguyên nhân, nhưng đoán là nguyên nhân đến từ cả hai, cách convert dữ liệu từ database sang Java type của Spring và cách dùng “<em>tùm lum</em>” Generic của Java(do yêu cầu phải tương thích ngược với các version cũ). Nhưng điều quan trọng không phải nguyên nhân, tốt nhất trong trường hợp này, hãy trả về đúng kiểu của field được khai báo trong entity.</p>
<p>Hiện đại quá cũng nhưng cũng thật nguy hiểm. Mình cảm nhận thấy là Spring Data JPA đang có rất nhiều vấn đề với kiểu trả về này(Hibernate đỡ hơn), bạn nào mà yếu là rất dễ xẩy chân, cứ tưởng là ngon lành nhưng test “<em>rờ</em>” đến đây “<em>chết</em>” đến đó.</p>
<p>Chú ý là tất cả các cách mình kể ở trên, đó chỉ là những cách mình khuyến khích, bạn hoàn toàn có thể sử dụng rất rất nhiều cách khác trong JPA/Hibernate để đạt mục đích, “đ<em>ường nào cũng dẫn đến La Mã</em>” thôi.</p>
<h2>Tóm lại, khi sử dụng, cần chú ý</h2>
<ul>
<li><p>Hiểu rõ những thành phần của JPA nói chung và Hibernate nói riêng. JPA có rất nhiều, nắm được càng nhiều, bạn càng code nhàn hơn. Chưa cần hiểu sâu, hãy hiểu rộng trước để biết những feature, sau này có bài toán cụ thể còn lôi feature ra mà dùng.</p>
</li>
<li><p>Hiểu rõ cách mà JPA provider đối xử với database. Bạn nghĩ ORM hoàn toàn không phụ thuộc vào loại database? Tỉnh lại và quên mấy lời quảng đấy đi.</p>
</li>
<li><p>Luôn luôn, chú ý tất cả những gì JPA/Hibernate đưa lên và lấy về từ database: log câu SQL, binding parameters và binding results, có thể dùng thêm statistics để monitor thêm. Về phía database cũng phải monitor để kiểm tra: resources, câu SQL, số lượng connection… không nên quá tin những ông nào code Java.</p>
</li>
</ul>
<h3>Reference</h3>
<p>Về Hibernate, khuyến khích mọi người nên follow website <a href="https://www.thoughts-on-java.org/">https://www.thoughts-on-java.org/</a> và đọc cuốn: <a href="https://www.amazon.com/Hibernate-Tips-solutions-common-problems-ebook/dp/B06XXGYZHS/ref=sr_1_1?tag=toj04-20">Hibernate Tips: More than 70 solutions to common Hibernate problems</a></p>
<p><a href="https://www.thoughts-on-java.org/common-hibernate-mistakes-cripple-performance/">10 Common Hibernate Mistakes That Cripple Your Performance</a></p>
<p><a href="https://vladmihalcea.com/eager-fetching-is-a-code-smell/">EAGER fetching is a code smell when using JPA and Hibernate</a></p>
<p><a href="https://www.thoughts-on-java.org/jpa-21-entity-graph-part-1-named-entity/">JPA 2.1 Entity Graph : Part 1- Named entity graphs</a></p>

          </div>
        </div><!-- .post-inner -->
      </article><!-- .post-content -->
      
  
  <nav class="post-pagination section-box">
    

    
    
      
    

    
    
      
    

    

    
        <div class="post-next">
          <h3 class="post-title"><a href="../../../vi/blog/ng-bao-gi-hai-long-vi-nhng-gi-minh-ang-bit/">Đừng bao giờ hài lòng với những gì mình đang biết</a></h3>

          <div class="post-info">
            <a href="javascript: void(0)"><i class="rsicon rsicon-user"></i>by luanvv</a>
            <a href="javascript: void(0)"><i class="rsicon"></i>Nov 21 2018</a>
          </div>
        </div>
    
    
        <div class="post-next">
          <h3 class="post-title"><a href="../../../vi/blog/optional-t-swift-ti-java-ti-sao-nen-dung-optional/">Optional, từ Swift tới Java. Tại sao nên dùng Optional?</a></h3>

          <div class="post-info">
            <a href="javascript: void(0)"><i class="rsicon rsicon-user"></i>by luanvv</a>
            <a href="javascript: void(0)"><i class="rsicon"></i>Oct 09 2018</a>
          </div>
        </div>
    
  </nav><!-- .post-pagination -->

    </main>
    <!-- .post-single -->
  </div>
</div>

      </div>
    </div><!-- .content -->
    <footer class="footer">
      <div class="footer-social">
        <ul class="social">
          <li>
              <a class="ripple-centered" aria-label="Github" rel="noopener" target="_blank" href="https://github.com/luanvuhlu">
                  <i class="rsicon rsicon-github"></i>
              </a>
          </li>
          <li>
              <a class="ripple-centered" aria-label="Facebook" rel="noopener" target="_blank" href="https://www.facebook.com/luanvuhlu" target="_blank">
                  <i class="rsicon rsicon-facebook"></i>
              </a>
          </li>
          <li>
              <a class="ripple-centered" aria-label="LinkedIn" rel="noopener" target="_blank" href="https://www.linkedin.com/in/luanvv/" target="_blank">
                  <i class="rsicon rsicon-linkedin"></i>
              </a>
          </li>
          <li>
              <a class="ripple-centered" aria-label="Skype" rel="noopener" target="_blank" href="skype:luanvuhlu"><i
                  class="rsicon rsicon-skype"></i>
              </a>
          </li>
          <li>
              <a class="ripple-centered" aria-label="Email" rel="noopener" target="_blank" href="mailto:luanvuhlu@gmail.com">
                  <i class="rsicon rsicon-email"></i>
              </a>
          </li>
      </div>
    </footer><!-- .footer -->
  </div><!-- .wrapper -->

  <a class="btn-scroll-top" href="#"><i class="rsicon rsicon-arrow-up"></i></a>
  <div id="overlay"></div>
  <div id="preloader">
    <div class="preload-icon"><span></span><span></span></div>
    <div class="preload-text">Loading ...</div>
  </div>
  <!-- Scripts -->
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<!--   <script type="text/javascript" src="../../../static/fonts/map-icons/js/map-icons.min.js"></script> -->
  <script type="text/javascript" src="../../../static/js/plugins/jquery.mousewheel-3.0.6.pack.js"></script>
  <script type="text/javascript" src="../../../static/js/plugins/imagesloaded.pkgd.min.js"></script>
  <script type="text/javascript" src="../../../static/js/plugins/isotope.pkgd.min.js"></script>
  <script type="text/javascript" src="../../../static/js/plugins/jquery.appear.min.js"></script>
  <script type="text/javascript" src="../../../static/js/plugins/jquery.onepagenav.min.js"></script>
  <script type="text/javascript" src="../../../static/js/plugins/jquery.bxslider/jquery.bxslider.min.js"></script>
 <!--  <script type="text/javascript" src="../../../static/js/plugins/jquery.customscroll/jquery.mCustomScrollbar.concat.min.js"></script> -->
  <!-- <script type="text/javascript" src="../../../static/js/plugins/jquery.mediaelement/mediaelement-and-player.min.js"></script> -->
  <!-- <script type="text/javascript" src="../../../static/js/plugins/jquery.fancybox/jquery.fancybox.pack.js"></script> -->
 <!--  <script type="text/javascript" src="../../../static/js/plugins/jquery.fancybox/helpers/jquery.fancybox-media.js"></script> -->
  <script type="text/javascript" src="../../../static/js/plugins/jquery.owlcarousel/owl.carousel.min.js"></script>
  <script type="text/javascript" src="../../../static/js/options.js"></script>
  <script type="text/javascript" src="../../../static/js/site.js"></script>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-128976168-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-128976168-1');

    const observer = lozad(); // lazy loads elements with default selector as '.lozad'
    observer.observe();

    (function ($) {
        "use strict";
        $('.post-editor>p>img').parent().addClass('img-block');
    })(jQuery);
  </script>
  

</body>
</html>
